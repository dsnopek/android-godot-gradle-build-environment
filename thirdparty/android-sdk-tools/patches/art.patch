diff --git a/libartbase/arch/instruction_set.h b/libartbase/arch/instruction_set.h
index c0d27c3..25fe13e 100644
--- a/libartbase/arch/instruction_set.h
+++ b/libartbase/arch/instruction_set.h
@@ -24,6 +24,43 @@
 #include "base/macros.h"
 #include "base/pointer_size.h"
 
+// see aosp/art/build/art.go
+// We need larger stack overflow guards for ASAN, as the compiled code will hav
+// larger frame sizes. For simplicity, just use global not-target-specific cflags.
+// Note: We increase this for both debug and non-debug, as the overflow gap will
+//       be compiled into managed code. We always preopt (and build core images) with
+//       the debug version. So make the gap consistent (and adjust for the worst).
+
+/*
+if len(ctx.Config().SanitizeDevice()) > 0 || len(ctx.Config().SanitizeHost()) > 0 {
+    cflags = append(cflags,
+        "-DART_STACK_OVERFLOW_GAP_arm=8192",
+        "-DART_STACK_OVERFLOW_GAP_arm64=16384",
+        "-DART_STACK_OVERFLOW_GAP_riscv64=16384",
+        "-DART_STACK_OVERFLOW_GAP_x86=16384",
+        "-DART_STACK_OVERFLOW_GAP_x86_64=20480")
+} else {
+    cflags = append(cflags,
+        "-DART_STACK_OVERFLOW_GAP_arm=8192",
+        "-DART_STACK_OVERFLOW_GAP_arm64=8192",
+        "-DART_STACK_OVERFLOW_GAP_riscv64=8192",
+        "-DART_STACK_OVERFLOW_GAP_x86=8192",
+        "-DART_STACK_OVERFLOW_GAP_x86_64=8192")
+}
+*/
+
+#define ART_STACK_OVERFLOW_GAP_arm 16384
+#define ART_STACK_OVERFLOW_GAP_arm64 16384
+#define ART_STACK_OVERFLOW_GAP_riscv64 16384
+#define ART_STACK_OVERFLOW_GAP_x86 16384
+#define ART_STACK_OVERFLOW_GAP_x86_64 20480
+
+// see aosp/art/build/art.go
+// default frame size limit: 1736
+// device limit: 7400
+// host limit: 10000
+#define ART_FRAME_SIZE_LIMIT 10000
+
 namespace art {
 
 enum class InstructionSet {
diff --git a/libartbase/base/mem_map.cc b/libartbase/base/mem_map.cc
index 0ab47f2..910e274 100644
--- a/libartbase/base/mem_map.cc
+++ b/libartbase/base/mem_map.cc
@@ -45,6 +45,20 @@
 #define MAP_ANONYMOUS MAP_ANON
 #endif
 
+// see aosp/build/soong/android/config.go
+/*
+func (c *config) LibartImgHostBaseAddress() string {
+	return "0x60000000"
+}
+
+func (c *config) LibartImgDeviceBaseAddress() string {
+	return "0x70000000"
+}
+*/
+
+// device base address
+#define ART_BASE_ADDRESS 0x70000000
+
 namespace art {
 
 using android::base::StringPrintf;
diff --git a/libdexfile/dex/dex_file.cc b/libdexfile/dex/dex_file.cc
index 2b68cfa..7e7ae56 100644
--- a/libdexfile/dex/dex_file.cc
+++ b/libdexfile/dex/dex_file.cc
@@ -718,6 +718,31 @@ dex::ProtoIndex DexFile::GetProtoIndexForCallSite(uint32_t call_site_idx) const
   return dex::ProtoIndex(it.GetJavaValue().i);
 }
 
+std::ostream& operator<<(std::ostream& os, EncodedArrayValueIterator::ValueType rhs) {
+  switch (rhs) {
+    case EncodedArrayValueIterator::kByte: os << "Byte"; break;
+    case EncodedArrayValueIterator::kShort: os << "Short"; break;
+    case EncodedArrayValueIterator::kChar: os << "Char"; break;
+    case EncodedArrayValueIterator::kInt: os << "Int"; break;
+    case EncodedArrayValueIterator::kLong: os << "Long"; break;
+    case EncodedArrayValueIterator::kFloat: os << "Float"; break;
+    case EncodedArrayValueIterator::kDouble: os << "Double"; break;
+    case EncodedArrayValueIterator::kMethodType: os << "MethodType"; break;
+    case EncodedArrayValueIterator::kMethodHandle: os << "MethodHandle"; break;
+    case EncodedArrayValueIterator::kString: os << "String"; break;
+    case EncodedArrayValueIterator::kType: os << "Type"; break;
+    case EncodedArrayValueIterator::kField: os << "Field"; break;
+    case EncodedArrayValueIterator::kMethod: os << "Method"; break;
+    case EncodedArrayValueIterator::kEnum: os << "Enum"; break;
+    case EncodedArrayValueIterator::kArray: os << "Array"; break;
+    case EncodedArrayValueIterator::kAnnotation: os << "Annotation"; break;
+    case EncodedArrayValueIterator::kNull: os << "Null"; break;
+    case EncodedArrayValueIterator::kBoolean: os << "Boolean"; break;
+    default: os << "EncodedArrayValueIterator::ValueType[" << static_cast<int>(rhs) << "]"; break;
+  }
+  return os;
+}
+ 
 // Checks that visibility is as expected. Includes special behavior for M and
 // before to allow runtime and build visibility when expecting runtime.
 std::ostream& operator<<(std::ostream& os, const DexFile& dex_file) {
